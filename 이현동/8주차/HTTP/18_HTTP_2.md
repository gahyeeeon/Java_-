## HTTP/2.0

기존 HTTP 1.1 버전의 성능 향상에 초점을 맞춘 프로토콜

1.1의 문제점 HOLB 를 해결하기 위해 여러 파일을 한번에 병렬로 전송

일반적으로 2.0 버전을 사용만해도 웹 응답 속도가 1.1에 비해 15~50% 향상 된다고한다.

## HTTP/2.0 개선점

### Binary Framing Layer

1.1에서는 메세지가 text로 전송되었던것이 2.0 에서는 binary frame로 인코딩되어 전송된다.

또한 1.1에서는 헤더와 바디를 개행문자로 구분하였는데, 2.0 에서는 layer 로 구분된다. 이로인해 데이터 파싱 및 전송 속도가 증가하고 오류 발생 가능성이 줄어들었다.

### Multiplexing

HTTP 헤더 메세지를 바이너리 형태의 프레임으로 나누고 하나의 커넥션으로 동시에 여러개의 메세지 스트림을 응답 순에 상관없이 주고 받는 것을 멀티플렉싱이라고 한다.

HTTP/1.1의 Connection Keep-Alive, Pipelining, Head Of Line Blocking을 개선했다.

latency만 줄여주는게 아니라 결국 네트워크를 효율적으로 사용할 수 있게 하고 그 결과 네트워크 비용을 줄여준다. 특히 클라우드 시스템을 이용한다면 비용과 직결된다.

### Server Push

HTTP 2.0에서는 클라이언트의 요청에 대해 미래에 필요할것 같은리소스를 똑똑하게 미리 보낼 수 있다.

예를 들어 클라이언트로부터 HTML 문서를 요청하는 하나의 HTTP 메세지를 받은 서버는 그 HTML 문서가 링크하여 사용하고 있는 이미지, CSS 파일, JS 파일 등의 리소스를 스스로 파악하여 클라이언트에게 미리 push해서 미리 브라우저의 캐시에 가져다 놓는다.

### Stream Prioritization

HTTP 1.1에서 파이프라이닝 이라는 혁신적인 기술이 있었지만, 우선 순위 문제 때문에 HOLB(Head Of Line Blocking)가 발생하여 사장되었다고 했었다.

HTTP 2에서는리소스간 의존관계(우선순위)를 설정하여 이런 문제를 해결하였다.

위에서 봤던 것 처럼 HTTP 메세지가 개별 바이너리 프레임으로 분할되고, 여러 프레임을 멀티플렉싱 할 수 있게 되면서 요청과 응답이 동시에 이루어져 비약적인 속도 향상이 되었다.

하지만 하나의 연결에 여러 요청과 응답이 뒤섞여 버려 패킷 순서가 엉망 징창이 되었다. 따라서 스트림들의 우선순위를 지정할 필요가 생겼는데, 클라이언트는우선순위 지정 트리를 사용하여 스트림에 식별자를 설정함으로써 해결 하였다.

각각의 스트림은 1-256 까지의 가중치를 갖음

하나의 스트림은 다른 스트림에게 명확한 의존성을 갖음

### HTTP Header Data Compression

2.0에서는 HTTP 메세지의 헤더를 압축하여 전송한다.

또한 1.1 에서는 연속적으로 요청되는 HTTP 메세지들에게서 헤더값이 중복되는 부분이 많아 역시 메모리가 낭비되었는데 2.0에서는 이전 Message의 헤더의 내용 중 중복되는 필드를 재전송하지 않도록하여 데이터를 절약할 수 있게 되었다.

만일 메세지 헤더에 중복값이 존재하는 경우, Static/Dynamic Header Table 개념을 사용하여 중복 헤더를 검출하고, 중복된 헤더는 index 값만 전송하고 중복되지 않은 Header 정보의 값은 호프만 인코딩 기법을 사용하는 HPACK 압축 방식으로 인코딩 처리하여 전송.

## HTTP 2.0 문제점

### RTT(Round Trip Time)

여전히 TCP를 이용하기 때문에 Handshake의 RTT로 인한 지연시간이 발생

### TCP 자체의 HOLB

기본적으로 TCP는 패킷이 유실되거나 오류가 있을때 재전송하는데, 이 재전송 과정에서 패킷의 지연이 발생하면 결국 HOLB 문제가 발생한다.

### 중개자 캡슐화 공격

HTTP 2.0은 헤더 필드의 이름과 값을 바이너리로 인코딩한다. 이를 다르게 말하면 HTTP 2.0 이 헤더 필드로 어떤 문자열이든 사용할 수 있게 해준다는 뜻이다.

그래서 이를 악용하면 HTTP 2.0 메시지를 중간의 Proxy 서버가 HTTP 1.1 메시지로 변환할 때 메시지를 불법 위조할수 있다는 위험성이 있다. 다행히 거꾸로 HTTP/1.1 메시지를 HTTP/2.0 메시지로 번역하는 과정에서는 이런 문제가 발생하지 않는다.

### 길다란 커넥션 유지로 인한 개인정보 누출 우려

HTTP 2.0은 기본적으로 성능을 위해 클라이언트와 서버 사이의 커넥션을 오래 유지하는 것을 염두에 두고 있다.

하지만 이것은 개인 정보의 유출에 악용될 가능성이 있다. 이는 HTTP/1.1에서의 Keep-Alive도 가지고 있는 문제이기도 하다.
