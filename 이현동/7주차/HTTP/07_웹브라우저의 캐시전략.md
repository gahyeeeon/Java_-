## 캐시 제어 헤더 종류

### Cache-Control 헤더

- 캐시의 유효 시간을 명시하는 응답 헤더

### Pragma 헤더

- HTTP/1.0 하위 호환을 위해 사용하는 캐시 제어 헤더
- Cache-Control과 동일한 역할을 수행하지만 권장되지 않음

### Expires 헤더

- 캐시의 만료일을 명시하는 헤더로, 정확한 날짜를 지정해야한다.
- Cache-Control 헤더에도 max-age로 유효시간을 명시하는것이 더 추천되기 때문에, 현재는 사용이 권장되지 않고 하위호환을 위해 사용된다.
- 만일 max-age와 동시에 사용되면 Expires는 무시된다.

## 캐시 유효 기간

캐시 유효기간을 길게 늘리면 불필요한 네트워크 요청을 많이 줄일수 있을것같지만 이는 좋지 않은 방법이다. 왜냐하면 오랜 기간 변경되지 않아도 되는 데이터가 있는 반면, 짧은 변경 주기를 가지는 데이터도 있기 때문이다. 즉, 만료기간이 긴 경우 캐시 데이터가 오래된 데이터일 가능성이 높아지게 된다.

따라서 비록 캐시 유효 기간이 지났더라도 오랜 기간 변경되지 않아도 되는 데이터일 경우 처음부터 요청을 하는건 낭비를 초래하는 요청이 된다는 소리이다.

그래서 더 효율적인 캐시 전략을 위해 웹 브라우저에는 별도의 캐시 검증 로직을 수행하게 된다.

사실 ‘캐시를 언제까지 유지해야 하는가?’ 의 문제는 답이 없다. 데이터의 성격과 상황에 맞게 설정해야한다.

## 캐시 검증 헤더 종류

서버가 클라이언트에게 응답할때 HTTP 메세지 헤더에 넣는 캐시 관련 헤더 정보.

### Last-Modified 헤더

- 데이터의 최종 수정 시각을 명시
- If-Modified-Since 요청 헤더와 함께 사용된다.
- 클라이언트가 캐시 유효 기간이 초과된 데이터를 서버에 요청하는 경우, 이를 기준으로 데이터가 수정되었는지 검증한다.
- 예를들어 서버의 데이터 최종 수정 시간이 Last-Modified 보다 이전이라면 데이터가 수정되지 않은것으로 간주하고, 이후라면 수정된것으로 간주한다.

### ETag 헤더

- 특정 버전의 리소스를 식별하는 고유 식별자(데이터의 버전 이름 혹은 해시값)
- 서버는 파일이 변경될 때마다 새 ETag 값을 생성하고 이전 ETag 값을 유지한다.
- If-None-Match 요청 헤더와 함께 사용된다.
- Last-Modified 헤더의 한계를 극복하기 위한 리소스 검증 헤더

## 조건부 요청 헤더 종류

클라이언트가 서버에 요청할때 HTTP 메세지 헤더에 넣는 캐시 관련 헤더 정보들.

### If-Modified-Since 헤더

- 클라이언트의 요청시 사용되며, 캐시 데이터의 Last-Modified 값이 들어간다.
- 서버의 데이터 최종 수정 시각과 캐시 데이터의 최종 수정 시각을 비교하여 데이터 수정 여부를 확인하기 위해 사용한다.
  - 수정시간이 같으면, 304 Not Modified 응답 → 캐시 재사용
  - 수정시간이 다르면, 200 OK 응답 → 새 데이터 전송

### If-None-Match 헤더

- 클라이언트의 요청시 사용되며, 캐시 데이터의 ETag 값이 들어간다.
- 서버의 데이터 ETag 와 캐시 데이터 ETag 를 비교하여 데이터 수정 여부를 확인하기 위해 사용된다.
  - 같다면, 304 Not Modified 응답 → 캐시 재사용
  - 다르면, 200 OK 응답 → 새 데이터 전송

### IF-Unmodified-Since / If-Match 헤더

- 각각 위 두 헤더의 반대 역할을 수행한다고 보면된다.
- 이 헤더들은 412 Precondition failed 상태 코드를 반환하는데 사용된다.

## HTTP 캐시 무효화

웹 브라우저의 캐시를 완전 제거하는것.

이러한 기술이 필요한 이유는, 웹 브라우저들이 GET 요청을 받을 경우 별도의 캐시 헤더 없이도 자기 마음대로 캐싱을 해버리기 때문.

또한, 리소스의 캐시 유효 기간을 길게 설정하고 리소스가 업데이트 되어 브라우저 캐시 저장소의 리소스가 업데이트가 필요한데, 기본적으로 브라우저는 캐시 유효 기간이 끝나야 캐시 유효성 검증을 서버에게 요청하기 때문에 어찌할 방도가 없다.

## 캐시 무효화 헤더

캐시를 사용해서는 안되는 페이지가 존재한다면, 다음과 같이 Cache-Control 헤더에 파라미터들을 설정해줘야한다.

**`Cache-Control: no-cache`**

- 데이터는 캐시해도 되지만 항상 서버에 검증하고 사용해야한다.
- 즉, 서버로부터 304 응답을 받아야 캐시 저장소에서 데이터를 가지고 올 수 있다는것.

**`Cache-Control: no-store`**

- 데이터에 민감한 정보가 있기에 저장하면 안됨
- 메모리에서 사용하고 최대한 빨리 삭제해야한다.

**`Cache-Control: must-revalidate`**

- 캐시 만료후 최초 조회시 서버에 검증해야할 때 설정
- 서버에 접근 실패시 반드시 504 오류가 발생해야하도록 한다.
- 만일 캐시 유효 시간 내에 있다면 캐시를 사용.

**`Pragma: no-cache`**

- HTTP 1.0 하위 호환용

## no-cache, must-revalidate 비교

캐시 무효화 헤더를 설정할때는 보는 no-cache, must-revalidate 를 같이 설정하는 편이다.

must-revalidate 가 사용되는 이유는 no-cahce에 의해 서버에 검증 요청을 보내는 도중 프록시 캐시 서버와 서버의 연결이 끊어져 검증이 불가능할 경우, 504 오류를 발생시키기 위해서이다.

왜냐하면 몇몇 프록시 캐시 서버에서는 원 서버(Origin)에 접근이 불가능해질 경우에 검증을 거치지 않고 이전의 캐시 데이터를 반환하기 때문.

예를들어, 통장잔고와 같은 중요 데이터의 경우, 서버와의 연결이 불가능하다고 해서 변경 전의 데이터를 반환하면 큰일이 나므로, must-revalidate를 활용해 일부로 5XX 오류를 발생시키는 전략을 세운다고 보면된다.

다만, must-revalidate 는 캐시 유효성 기간이 남아있으면 우선적으로 캐시 저장소를 조회하게 되어있다. 따라서 네트워크 문제 해결과 항상 서버에 캐시 검을을 함께 사용하고 싶은 경우 no-cache 와 함께 설정해주면 된다.
