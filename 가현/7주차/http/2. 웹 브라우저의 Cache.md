# 2. 웹 브라우저의 Cache

캐시(Cache)

주기억장치에서 자주 사용하는 프로그램과 데이터를 하드디스크로부터 가져오는데 시간이 많이 걸리니 캐시 저장소에 임시로 적재해두고 빠르게 접근하기 위한 기술

임시 저장소에 적재해놓고 빠르게 엑세스함으로써 처리 성능을 높임

캐시 제어 헤더 종류

**Cache-Control 헤더 종류**

캐시의 유효 시간(생명 주기)을 명시하는 응답(Resonse) 헤더

- max-age : 캐시 유효 시간, 초 단위
- no-cache : 데이터는 캐시해도 되지만, 항상 Origin Server에 검증 후 사용
- no-store : 데이터에 민감한 정보가 포함되어 있어 저장 불가 혹은 최대한 빨리 삭제
- public : public 캐시(프록시 캐시 서버)에 저장 가능
- private : 프록시 캐시 서버에 적용되는 max-age
- Age : Origin Server의 응답이 프록시 캐시 서버에 머문 시간(sec)
- must-revalidate : 캐시 만료 후 최초 조회시 Origin Server에 검증

콤마로 여러 파라미터 열거 가능

**Pragma 헤더**

HTTP/1.0 하위 호환을 위해 사용하는 캐시 제어 헤더

Cache-Control과 동일한 역할을 수행하지만 권장되지 않는다

**Expires 헤더**

캐시 만료일을 명시하는 헤더, 정확한 날짜 지정

Cache-Control 헤더에도 max-age로 유효 시간을 명시하는 것이 더 추천

max-age와 동시에 사용되면 Expires 무시

**캐시가 없을 경우**

- 클라이언트에서 이미지 요청
- 서버에서는 해당 이미지가 있으면 응답, 이미지의 HTTP 헤더 + 바디를 합쳐 대략 1.1M정도 용량의 데이터로 응답
- 클라이언트에서는 해당 이미지를 응답 받아 사용
- 클라이언트에서는 이미지를 재요청
- 서버에서 동일한 이미지를 다시 1.1M정도 용량의 데이터를 응답
- 클라이언트에서 해당 이미지를 응답 받아 사용
- 동일한 이미지를 요청하는 데 네트워크를 통해 같은 데이터를 다운

**캐시를 이용한 요청**

- 클라이언트에서 이미지 요청
- 서버에서 해당 이미지 응답, HTTP메세지에 cache-control 헤더를 넣어 캐시가 유효한 시간을 설정
- 서버로 응답 받게 되면, 클라이언트에서는 cache-control 헤더를 이해하고 웹브라우저 캐시에 응답 결과를 유효 시간만큼 저장
- 클라이언트가 이미지 재요청, 이 때 서버에게 가는 것이 아닌 우선 캐시 저장소를 조회
- 만일 캐시 되어있고 유효 시간내 요청한 상태라면, 캐시에서 자료 가져옴

**→ 유효시간이 지날 경우**

- 클라이언트가 이미지 재요청
- 서버에게 처음과 같이 요청
- 똑같이 cache-control헤더를 응답, 브라우저에 저장

HTTP 캐시 검증 & 조건부 요청

**Last-Modified 헤더**

데이터의 최종 수정 시각 명시

If-Modified-Since 요청(Request) 헤더와 함께 사용

클라이언트가 캐시 유효 기간이 초과된 데이터를 서버에 요청하는 경우, 데이터가 수정되었는지 검증

**ETag 헤더**

특정 버전의 리소스를 식별하는 고유 식별자(데이터의 버전 이름 혹은 해시값)

서버는 파일이 변경될 때마다 새 ETag값을 생성하고 이전 값 유지

If-None-Match 요청(Request) 헤더와 함께 사용

Last-Modified 헤더의 한계를 극복하기 위한 리소스 검증 헤더

조건부 요청 헤더 종류

**If-Modified-Since 헤더**

클라이언트의 요청(Request)시 사용, 캐시 데이터의 Last-Modified 값이 들어감

서버의 데이터 최종 수정 시각과 캐시 데이터의 최종 수정 시각을 비교하여 데이터 수정 여부를 확인하기 위해 사용

같으면 → 304 Not Modified 응답 → 캐시 재사용

다르면 →200 OK 응답 → 새로 데이터 전송 (네트워크 다운로드)

**If-None-Match 헤더**

클라이언트의 요청(Request)시 사용, 캐시 데이터의 ETag값이 들어감

서버의 데이터 ETag와 캐시 데이터의 ETag를 비교하여 데이터 수정 여부를 확인하기 위해 사용

같으면 →304 Not Modified 응답 → 캐시 재사용

다르면 →200 OK 응답 → 새로 데이터 전송 (네트워크 다운로드)

**If-Unmodified-Since / If-Match 헤더**

각각 If-None-Match 와If-Modified-Since 반대 역할 수행

웹브라우저의 조건부 요청 & 검증 동작

**문서 수정 시간 방식(Last-Modified & if-modified-since)**

- 클라이언트에서 이미지 요청
- 서버는 cache-control 헤더를 이용하여 캐시 유효 기간 설정, 추가적으로 Last-Modified헤더를 통해 리소스의 마지막으로 수정된 시간 정보를 넣어 응답
- 클라이언트는 응답 결과를 캐시에 저장할 때 데이터 최종 수정일도 저장
- 캐시 유효 시간이 초과된 상태에서, 클라이언트에서 이미지 재요청
- 캐시에 최종 수정일 정보(Last-Modified)가 있다면, 클라이언트 요청 메세지에 if-modified-since헤더에 해당 날짜를 담아 서버에 보냄
- 서버에서 만일 클라이언트가 요청한 헤더의 자료 최종 수정일과 서버에 있는 자료의 수정일을 비교해서 데이터가 수정이 안되었을 경우, 304 Not Modified 상태 코드로 응답
- 304 응답을 받은 클라이언트는 리소스 수정이 없어 최신 상태임을 인지하게 되고, 안전하게 캐시에서 다시 리소스를 가져오고 다시 캐시 유효 기간 갱신

**Last-Modified & if-modified-since 방식의 한계점**

- 1초 미만(0.x초)단위로 캐시 조정이 불가능
- 날짜 기반의 로직을 사용하여 한계
- 서버에서 별도의 캐시 로직을 관리하고 싶은 경우 한계

**프록시(Proxy) 캐시**

프록시 : 클라이언트와 본 서버를 중계하는 중간에 위치한 서버 대리자로서, 클라이언트의 요청을 대신 받고 본 서버에 전해주는 역할

같은 국내에 있기에 원 서버에 접근하는 것보다 훨씬 빠른 속도에 자료를 가져올 수 있음

클라이언트에서 사용되고 저장되는 캐시 : private 캐시

프록시 캐시 서버의 캐시 : public 캐시

**캐시 무효화(Cache Busting)**

웹브라우저의 캐시를 완전 제거

자기 마음대로 최적화를 위해 임의로 캐싱하여 필요

**no-cache vs must-revalidate비교**

**no-cache 기본 동작**

- 클라이언트는  E-Tag와 no-cache 설정하고 서버에 요청
- 중간에 프록시 캐시 서버 받고, no-cache 설정으로 다시 원 서버에 요청
- 원 서버에서 E-Tag로 검증
- 프록시에게 304 응답
- 프록시는 다시 클라이언트에게 응답
- 클라이언트는 캐시 재사용

**must-revalidate 동작**

- 클라이언트는  E-Tag와 no-cache 설정하고 서버에 요청
- 중간에 프록시 캐시 서버에 다시 원 서버에 요청하는데, 어떤 이유료 네트워크가 단절되어 접슨 불가
- 그러면 must-revalidate에서 무조건 504 Gateway TImeout 오류를 응답
- 클라이언트는 원 서버에 문제가 있음을 감지하고 별도의 재수정 로직을 거침