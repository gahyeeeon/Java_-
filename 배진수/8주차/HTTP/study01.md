# 4XX (Client Error) 상태 코드

# 4XX Client Error

- 4xx 번대의 상태 코드들은 클라이언트 오류를 의미하며, 잘못된 문법 등의 오류로 인해 서버가 요청을 수행할 수 없고 그 원인이 클라이언트에게 있음을 뜻한다.
- 예를들어 잘못 구성된 요청 메세지 규칙 같은 것이 있을 수 있으며, 존재하지 않은 URL 요청도 있을 수 있다.

## 400 Bad Request

- Bad Request → 클라이언트가 잘못된 요청을 보냄을 의미
- 클라이언트의 잘못된 요청으로 서버가 이해할수가 없어 요청을 수행할 수 없음을 뜻한다.
- 주로 요청 구문, 메시지 등의 문법 오류로 인한 문제가 해당되며 요청 파라미터가 잘못되거나 API 스펙이 맞지 않는 경우에도 400 상태코드를 내뱉는다. 따라서 이를 해결하기 위해서는 클라이언트가 자신의 요청을 검토하고 재전송하여야 한다.
- 서버는 상태 코드와 더불어 바디에 에러 이유를 구체적으로 명시하고 응답하는 것이 좋다.

## 401 Unauthorized

- Unauthorized ⇢ 요청자는 인증(authentication) 되지 않아 수행할 수 없음을 표현
- 클라이언트가 해당 리소스에 대한 인증이 없어 접근할 수 없다는 의미이다. (예를 들면 로그인 하지않으면 해당 서비스를 이용하지 못하는 것)
- 서버는 클라이언트에게 인증하라고 요구하는 내용의 응답을 WWW-Authenticate 헤더와 함께 반환한다. 클라이언트는 이를 참고하여 인증을 거쳐 요청을 재전송하면 된다.
- 참고로 401 응답은 Unauthorized 가 아닌 Unauthenticated 가 알맞는 단어이다.

## 402 Payment Required

- 원래는 디지털 결제 시스템에 사용하기 위하여 만들어졌지만, 현재 이 상태 코드는 쓰이지 않는다.
- 나중에 사용될 것을 대비해 예약된 비표준 응답 코드

## 403 Forbidden

- Forbidden → 요청자는 승인(autorization)되지 않아 작업을 진행할수 없음
- 인증 자격은 증명되었으나, 접근 권한이 불충분하여 서버가 요청의 승인을 거부했음을 의미하는 것이다.
- 예를들어 회원에도 등급이 존재하는데, 만일 admin 등급이 아닌 사용자가 admin 등급의 리소스에 접근을 요청하였을 때 403 Forbidden 메시지를 응답받게 된다.
- 401 Unauthorized과 다른 점은 서버가 클라이언트가 누구인지 알고 있다는 점이다. (인증 되었으니)

## 404 Not Found

- Not Found → 클라이언트가 요청한 자원이 존재하지 않음
- 서버가 요청한 URL을 찾을 수 없음을 알려주기 위해 사용한다. 정말 유명한 상태 코드.
- 404 페이지를 띄우는 링크는 대체로 브로큰 링크(broken link) 또는 데드 링크(dead link)라고 부른다.
- 다만 404 응답을 마주쳤다고 해서 무조건적으로 해당 리소스가 서버에 존재하지 않는다는 의미는 아니다. 서버는 인증받지 않은 클라이언트로부터 리소스를 숨기기 위하여 이 응답을 403 대신에 404를 전송하는 케이스도 있기 때문이다.
- 또한 404 상태 코드는 리소스가 일시적 또는 영구적으로 사라졌다는 것을 의미하지는 않다. 만일 리소스가 영구적 삭제되었다면 404 상태 코드 대신 410 Gone 상태 코드를 쓰는 것이 맞다.

## 405 Method Not Allowed

- Method Not Allowed → 요청이 허용되지 않은 메소드임을 의미
- 요청 URL에 대해 지원하지 않은 메서드로 요청받았을 때 사용한다.
- 예를들어 어느 api에 대해서 리소스를 삭제하는 것을 금지하거나에 사용될 수 있다.
- 이때 요청한 리소스에 대해 어떤 메서드가 사용 가능한지 클라이언트에게 알려주기 위해, 응답에 Allow 헤더가 포함되어야 한다.
- 단, GET와 HEAD는 필수 메서드로 처리되기 때문에 405 응답으로 제한할수 없다.

## 406 Not Acceptable

- Not Acceptable → 콘텐츠 협상에 일치하는 것이 없음
- 이 응답은 서버가 서버 주도 콘텐츠 협상을 수행한 후, 사용자 에이전트에서 보낸 규격에 어떠한 콘텐츠도 찾지 못했을 때 보내는 응답이다.
- 종종 서버는 클라에게 왜 요청이 만족될 수 없었는지 알려주는 헤더를 포함시킨다.
- 단, 현업에서는 이 오류 코드를 거의 사용하지 않는다.

## 407 Proxy Authentication Required

- Proxy Authentication Required → 프록시 인증을 요구
- 401 Unauthorized 와 같으나, 프록시 버전이라고 보면 된다. (여기선 Authentication 이라고 제대로 표현되었다)
- 리소스에 대해 중개 프록시 서버에 의해 완료된 인증이 필요하다는 뜻이다.
- 프록시 서버는 접근 정책을 중앙 관리할 수 있기 때문에 단일 관리 포인트로도 많이 사용되기 때문에 이에 관련된 상태 코드를 따로 지원하는 것이다.
- 단, 프록시와 웹 서버 인증 헤더가 조금 다르다.

## 408 Request Timeout

- Request Timeout → 요청이 너무 커 처리 시간이 초과되어 서버에서 요청을 처리하지 아니하고 연결을 닫음
- 만일 클라이언트의 요청을 완수하기에 시간이 너무 많이 걸리는 경우, 서버는 이 상태 코드로 응답하고 연결을 끊을 수 있다.
- 혹은 인터넷 연결이 매우 느리거나 끊어졌기 때문에 발생할 수도 있다.
- 서버의 타임 아웃 기준은 서버 설정마다 다르다.
- 408 응답은 서버가 연결을 닫기로 결정했음을 의미하므로, 응답할때 `Connection: close` 헤더를 반드시 전송해야 한다.
- 이 응답은 Chrome, Firefox 27+, IE9와 같은 일부 브라우저들이 웹서핑 속도를 높이기 위해 HTTP 사전 연결 메커니즘을 사용하기 때문에, 만일 네트워크가 불안정하면 종종 볼수 있는 응답이기도 하다.

## 409 Conflict

- Conflict → 클라이언트의 요청이 서버의 상태와 충돌이 발생
- 요청 처리 중 비지니스 로직상 불가능하거나 모순이 생긴 경우 사용된다.
- 여타 4XX 상태 코드 처럼 요청에 있어 메소드 지원 유무나, 자원 유무, 인증 유무와 같은 확실한 오류 상황들을 제외한 로직 오류 상황에서 쓰인다.
- 사실 충돌(conflict)이라는 것은 추상적인 오류 현상이기 때문에, 여타 4XX 상태 코드에 속하지 않은 애매한 오류의 상황들을 처리하는데 이용된다고 보면 된다.
- 그래서 응답은 충돌에 대해 설명하는 구체적인 본문을 포함해야 한다.

## 410 Gone

- Gone → 리소스가 영구히 삭제됨
- 404 Not Found와 비슷하나 410 응답은 요청한 컨텐츠가 서버에서 영구히 삭제되어 전달해 줄 주소가 존재하지 않을때 사용된다.

## 411 Length Required

- Length Required → 요청 메시지에 `Content-Length` 헤더가 있을 것을 요구
- 서버에서 로직을 처리하는데 필요로 하는 `Content-Length` 헤더 필드가 없어 서버가 요청을 거절할때 응답된다.
- 클라이언트가 서버에 chunk 데이터를 보낼때, 인코딩을 받아들여주지 않을 경우에도 이용된다.
- 클라이언트는 요청 헤더에 `Content-Length` 를 포함하고 재요청하면 된다.

## 412 Precondition Failed

- Precondition Failed → 클라이언트의 조건부 요청 실패
- 클라이언트가 캐시에 대한 조건부 요청을 했는데 실패했을 때 응답된다. (Etag나 수정일짜 불일치)
- 304 Not Modified 처럼 캐시 관련 요청에서 쓰이는 코드이다.
- 단, POST, PUT, DELETE 메소드 등 GET, HEAD 이외의 메소드에서만 요청했을때만 사용된다.
- 이 상태 코드를 따르면 '업데이트 손실' 문제를 피할 수 있다. 업데이트 손실은 여러 사람이 동일한 리소스를 쓰고 있고 한 명 이상이 오래된 버전으로 작업할 때, 리소스가 수정되지 않았는지 확인함으로써 중간에 수정된 데이터를 덮어쓰거나 수정하지 않도록 보장한다.

## 413 Payload Too Large

- Payload Too Large → 요청 본문이 서버에서 정의한 한계보다 너무 커 처리할수 없음
- 413 Request Entity Too Large 로도 쓰여짐
- 서버가 처리할 수 있는 한계를 넘은 크기의 본문을 포함한 요청을 클라이언트가 보냈을 때 사용한다.
- 서버는 연결을 끊거나 혹은 `Retry-After` 헤더 필드로 돌려보낼 것이다.

## 414 URI Too Long

- URI Too Long → 요청 URI이 너무 길어 처리할수 없음
- 413 Request URI Too Long 로도 쓰여짐
- 서버가 처리할 수 있는 한계를 넘은 길이의 요청 URI를 클라이언트가 보냈을때 응답된다.

## 415 Unsupported Media Type

- Unsupported Media Type → 요청한 미디어 포맷은 서버에서 지원하지 않음
- 서버가 이해하거나 지원하지 못하는 내용 유형의 본문을 클라이언트가 보낼때 응답된다.

## 416 Range Not Satisfiable

- Range Not Satisfiable → Range 헤더 필드에 요청한 지정 범위를 만족시킬 수 없음
- 클라이언트가 리소스의 특정 범위를 요청했는데, 그 범위가 잘못되었거나 맞지 않을 때 응답된다.

## 417 Expectation Failed

- Expectation Failed → Expect 요청 헤더 필드로 요청한 예상 반환 코드를 만족 시킬 수 없음
- Expect 요청 헤더와 연관있는 상태 코드 (성공하면 100, 실패하면 417)

## 418 I’m a teapot

- I’m a teapot → 만우절 농담 상태 코드
- 이 오류는 1998년 만우절 농담이었던 하이퍼 텍스트 커피 포트 제어 규약(Hyper Text Coffee Pot Control Protocol)의 레퍼런스다.

## 420 Method Failure or Enhance your calm

- 클라이언트 오류를 나타내기 위해 서버에서 반환하는 비공식 클라이언트 오류
- Spring Framework에서 메서드가 실패했음을 나타내는 비공식 응답코드로도 쓰였음 (지금은 안쓰임)

## 421 Misdirected Request

- Misdirected Request → 잘못된 방향의 요청
- 의도하지 않은 요청을 받아 서버가 응답을 생성할 수 없음을 나타냄

## 422 Unprocessable Entity

- Unprocessable Entity → 서버에서 본문을 처리할수 없음
- 이 응답은 서버가 요청을 이해하고 요청 문법도 올바르지만 요청된 지시를 따를 수 없음을 나타냄
- 요청 데이터에 대해 validation 처리를 하면서 적합하지 않은 데이터를 받았을 때 반환

## 423 Locked

- Locked → 리소스는 접근하는 것이 잠겨있음
- 요청에 대한 대상 파일 또는 폴더가 잠겨 있을때 반환
- WebDAV에 사용되는 응답 코드

## 424 Failed Dependency

- 요청된 작업이 실패한 다른 작업에 의존하기 때문에 수행할 수 없음
- 즉, 이전 요청이 실패하였기 때문에 지금의 요청도 실패하였음을 의미
- WebDAV에 사용되는 응답 코드

## 426 Upgrade Required

- Upgrade Required → 프로토콜 업그레이드 권고
- 서버가 현재 프로토콜을 사용하여 요청을 수행 의사가 없음을 나타내기 위해 반환되는 응답 코드이다.
- 예를들어 서버는 HTTP/1.1 버전은 받지않고 HTTP/2 이상만 받는다고 할때, 클라이언트가 HTTP/1.1로 요청을 보내는 상황을 말할 수 있다.
- 서버는 응답할때 `Upgrade` 헤더에 필요로 하는 프로토콜을 클라이언트에게 알려준다.
- 프로토콜 관련 101 Switching Protocols 상태 코드와 관련이 있다.

## 428 Precondition Required

- Precondition Required ⇢ 조건부 요청이 요구됨
- 서버가 클라이언트에게 요청을 조건부로 해야 함을 나타낸다.
- 일반적으로 `If-Match`와 같은 필수 전제 조건부 헤더가 누락됬을때 반환된다.
- 만일 조건부 헤더가 서버 측 리소스 상태와 일치하지 않을 경우 응답은 412 Precondition Failed가 되게 된다.

## 429 Too Many Requests

- Too Many Requests ⇢ 클라이언트가 일정 시간 동안 너무 많은 요청을 보낸 경우
- 서비스가 클라이언트의 요청량을 제한하려는 경우 이용된다. (예를 들어 API 사용건수를 시간당 100개 로 제한)
- 혹은 디도스와 같은 비정상적인 방법으로 자원을 마구마구 요청하는 경우, 서버는 가용성을 위해 요청 임시 제한을 걸 수 있다.
- `Retry-After` 헤더를 이용하여 몇초 뒤에 재시도 할 것을 나타낸다.

## 서버 공격에 대한 방어책

### 무차별 대입 공격에 대한 방어

- 무차별 대입 기밀성 공격(Brute-force)은 해커가 사용자의 비밀번호를 알아내기 위해, 패스워드값을 무작위로 넣고 로그인 요청을 무차별적으로 하는 것을 말한다.
- 서버는 요청에 제한을 두지않게되면 회원의 기밀성이 피해를 입을수 있으며 또한 서버 자체의 가용성에도 피해를 입을 수 있다.
- 따라서 서버는 이러한 공격에 대비해 인증관련 API 요청의 경우 **n 시간 동안 n회만 요청 가능 하다**는 룰을 정하고, 이것을 초과할 경우 429 응답을 하도록 설계한다.

### 디도스 공격에 대한 방어

- 도스(Dos) 공격 혹은, 디도스(D-Dos) 공격은 사용자의 정보 탈취가 목적이 아닌 무차별적인 요청으로 서버 자체에 과부하를 줘서 서비스를 먹통으로 만드는 것을 말한다.
- 이 공격을 단일이 하면 도스 공격이고 단체가 하면 디도스 공격이다.
- 따라서 서버는 **n 시간 동안 n회만 요청 가능 하다는 룰**을 정할 필요가 있는데, 단 429 상태 코드가 서버의 가용성에 대한 공격을 완벽히 막을수 있는 것은 아니다.
- 왜냐하면 서버 자체에 지속적인 요청 공격이 오는 것 자체는 막을수는 없기 때문이다. 429 응답을 해도 서버는 요청을 계속 받기 때문에,  따라서 추가적으로 네트워크 단에서 IP를 차단하는 조치가 필요하다.
- 하지만 그래도 서버는 429 응답을 통해 클라이언트 요청이 데이터베이스나 서버 내부 로직을 들쑤시고 다니는 것을 방어는 할수있기 때문에, 네트워크 엔지니어는 IP나 도메인에 대한 제한 처리를하고 백엔드 개발자는 429 응답을 통해 API 제한을 설정할 필요성이 있다.

## 431 Request Header Fields Too Large

- Request Header Fields Too Large → 헤더 필드가 너무 커서 요청을 처리하지 않음
- 총 요청 헤더 필드 수가 너무 많은 경우 또는 단일 헤더 필드가 너무 큰 경우 응답된다.
- 클라이언트는 요청 헤더 필드의 크기를 줄인 후 재요청 하면 된다.

## 451 Unavailable For Legal Reasons

- Unavailable For Legal Reasons → 법적인 이유로 비허용됨
- 클라이언트가 법적 이유로 사용할 수 없는 불법적인 리소스를 요청했음을 나타낸다. (정부에 의해 검열된 웹페이지 등)