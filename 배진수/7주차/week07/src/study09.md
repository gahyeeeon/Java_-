# 2. 개발에 앞서 알면 좋은 기초 지식

## 2.1 서버 간 통신

- 포털 사이트 하나를 단일 서비스로 구성하여 개발한다고 하면 서버를 업데이트하거나 애플리케이션을 유지보수 할 때 마다 서비스를 중단 시키고 작업을 해야한다
- 이 같은 문제를 해결하기 위해 나온 것이 마이크로서비스 아키택처(MSA : Microservice Archiecture)
- MAS는 단어 그대로 서비스 규모를 작게 나누어 구성한 아키텍처를 뜻한다
- 앞의 단일 서비스 사이트를 MSA를 적용한다면 서비스 기능별로 구분해서 독립적인 애플리케이션을 개발하게 되면 각 서비스 간에 통신해야 하는 경우가 발생한다
- 이런 상황을 ‘서버 간 통신’ 이라고 한다
- 서버 간 통신은 한 서버가 다른 서버에 통신을 요청하는 것을 의미하며, 한 대는 서버, 다른 한 대는 클라이언트가 되는 구조이다
- 몇 가지 프로토콜에 의해 다양한 통신 방식을 적용할 수 있지만 가장 많이 사용 되는 방식은 HTTP/HTTPS 방식이다

## 2.2 스프링 부트의 동작 방식

- 스프링 부트에서 spring-boot-starter-web 모듈을 사용하면 기본적으로 톰캣(Tomcat)을 사용하는 스프링 MVC 구조를 기반으로 동작한다.
- 아래는 일반적인 웹 요청이 들어왔을 때의 스프링 부트의 동작 구조이다.

!https://user-images.githubusercontent.com/13410737/178304203-73309bc8-8e24-4c90-81e6-dd645acd09ee.png

- 서블릿은 클라이언트의 요청을 처리하고 결과를 반환하는 자바 웹 프로그래밍 기술이다. 일반적으로 서블릿은 서블릿 컨테이너(Servlet Container)에서 관리한다.
- 서블릿 컨테이너는 서블릿 인스턴스(Servlet Instance)를 생성하고 관리하는 역할을 수행하는 주체로서 톰캣은 WAS의 역할과 서블릿 컨테이너의 역할을 수행하는 대표적인 컨테이너이다.
- 서블릿 컨테이너의 특징
    - 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기를 관리한다.
    - 서블릿 객체는 싱글톤 패턴으로 관리된다.
    - 멀티 스레딩을 지원한다.
- 스프링에서는 DispatcherServlet이 서블릿의 역할을 수행한다. 일반적으로 스프링은 톰캣을 임베드(embed)해 사용한다. 그렇게 때문에 서블릿 컨테이너와 DispatcherServlet 은 자동 설정된 web.xml 의 설정 값을 공유한다.
- DispatcherServlet 의 동작
    1. DispatcherServlet 으로 요청(HttpServletRequest)이 들어오면 DispatcherServlet은 핸들러 매핑(Handler Mapping)을 통해 요청 URL에 매핑된 핸들러를 탐색한다.
        - 여기서 핸들러는 컨트롤러(Controller)를 의미한다.
    2. 핸들러 어댑터(HandlerAdapter)로 컨트롤러를 호출한다.
    3. 핸들러 어댑터에 컨트롤러의 응답이 돌아오면 ModelAndView로 응답을 가공해 반환한다.
    4. 뷰 형식으로 리턴하는 컨트롤러를 사용할 때는 뷰 리졸버(View Resolver)를 통해 뷰(View)를 받아 리턴한다.
- 핸들러 매핑은 요청 정보를 기준으로 어떤 컨트롤러를 사용할지 선정하는 인터페이스이다. 핸들러 매핑 인터페이스는 여러 구현체를 가지며, 대표적인 구현체 클래스는 다음과 같다.
    - `BeanNameUrlHandlerMapping`
        - 빈 이름을 URL로 사용하는 매핑 전략이다.
        - 빈을 정의할 때 슬래시(‘/’)가 들어가면 매핑 대상이 된다.
        - 예) @Bean(“/hello”)
    - `ControllerClassNameHandlerMapping`
        - URL과 일치하는 클래스 이름을 갖는 빈을 컨트롤러로 사용하는 전략이다.
        - 이름 중 Controller를 제외하고 앞 부분에 작성된 suffix를 소문자로 매핑한다.
    - `SimpleUrlHandlerMapping`
        - URL 패턴에 매핑된 컨트롤러를 사용하는 전략이다.
    - `DefaultAnnotationHandlerMapping`
        - 어노테이션으로 URL과 컨트롤러를 매핑하는 방법이다.
- 뷰 리졸버는 뷰의 렌더링 역할을 담당하는 뷰 객체를 반환한다.

!https://user-images.githubusercontent.com/13410737/178307234-2b870321-4503-4f93-a197-7d1ebaa80fee.png

- 뷰가 없는 REST 형식의 @ResponseBody를 사용한다면 뷰 리졸버를 호출하지 않고 MessageConverter 를 거쳐 JSON 형식으로 변환해서 응답한다.

!https://user-images.githubusercontent.com/13410737/178307708-c258722d-4700-42b6-a23a-a287dc315373.png

- MessageConverter는 요청과 응답에 대한 Body 값을 변환하는 역할을 수행한다.
- 스프링 부트의 자동 설정 내역을 보면 httpMessageConverter 인터페이스를 사용하고 있다.
- 아래 예제는 spring.factories 에 정의된 HttpMessageConvertersAutoConfiguration 클래스이다.

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(HttpMessageConverter.class)
@Conditional(NotReactiveWebApplicationCondition.class)
@AutoConfigureAfter({ GsonAutoConfiguration.class, JacksonAutoConfiguration.class,
                    JsonbAutoConfiguration.class})
@Import({ JacksonHttpMessageConvertersConfiguration.class, GsonHttpMessageConvertersConfiguration.class,
        JsonbHttpMessageConvertersConfiguration.class })
public class HttpMessageConvertersAutoConfiguration{
    static final String PREFERRED_MAPPER_PROPERTY = "spring.mvc.converts.preferred-json-mapper";
    
    @Bean
    @ConditionalOnMissingBean
    public HttpMessageConverters messageConverters(ObjectProvider<HttpMessageConverter<?>> converters){
        return new HttpMessageConvertes(converters.orderedStream().collect(Collectors.toList()));
    }
    
    ...생략...
}
```

- 2번째 줄의 httpMessageConverter 인터페이스를 빈으로 등록하는 것을 볼 수 있다. 해당 인터페이스를 기반으로 하는 구현체 클래스는 다양하며, Content-Type을 참고해서 Converter 를 선정한다. **스프링 부트에서는 자동 설정되기 때문에 별도 설정이 필요하지 않다.**

## 2.3 레이어드 아키텍처

- 레이어드 아키텍처(Layerd Architecture)란 애플리케이션의 컴포넌트를 유사 관심사를 기준으로 레이어로 묶어 수평적으로 구성한 구조를 의미한다.
- 에이어드 아키텍처는 여러 방면에서 쓰이는 개념이며 어떻게 설계하느냐에 따라 용어와 계층의 수가 달라딘다.
- 일반적으로 레이어드 아키텍처라 하면 3계층 또는 4계층 구성을 의미하는데 이 차이는 인프라(데이터 베이스)레이어의 추가 여부로 결정된다.

!https://user-images.githubusercontent.com/13410737/179356109-f104a036-004e-4744-8712-54cfb6b63034.png

### 프레젠테이션 계층

- 애플리케이션의 최상단 계층으로, 클라이언트의 요청을 해석하고 응답하는 역할이다.
- UI나 API를 제공한다.
- 프레젠테이션 계층은 별도의 비즈니스 로직을 포함하고 있지 않으므로 비즈니스 계청으로 요청을 위임하고 받은 결과를 응답하는 역할만 수행한다.

### 비즈니스 계층

- 애플리케이션이 제공하는 기능을 정의하고 세부 작업을 수행하는 도메인 객체를 통해 업무를 위임하는 역할을 수행한다.
- DDD(Domain-Driven-Design) 기반의 아키텍처에서는 비즈니스 로직에 도메인이 포함되기도 하고, 별도로 도메인 계층을 두기도 한다.

### 데이터 접근 계층

- 데이터베이스에 접근하는 일련의 작업을 수행한다.
- 레이어드 아키텍처는 하나의 애플리케이션에도 적용되지만 애플리케이션 간의 관계를 설명하는 데도 사용할 수 있다.
- 레이어드 아키텍처 기반 설계는 다음과 같은 특징이 있다.
    - 각 레이어는 가장 가까운 하위 레이어의 의존성을 주입받는다.
    - 각 레이어는 관심사에 따라 묶여 있으며, 다른 레이어의 역할을 침범하지 않는다.
        - 각 컴포넌트의 역할이 명확하므로 코드의 가독성과 기능 구현에 유리하다.
        - 코드의 확장성도 좋아진다.
    - 각 레이어가 독립적으로 작성되면 다른 레이어와의 의존성을 낮춰 단위 테스트에 용이하다.

- 스프링 부트는 별도의 설정 없이 spring-boot-starter-web 의 의존성을 사용할 때는 기본적으로 스프링 MVC 구조를 띠게 되며, 대체로 아래와 같은 레이어드 아키텍처를 이룬다.

!https://user-images.githubusercontent.com/13410737/179356088-deb4dd3b-b062-4b5b-8d71-452a890bb2fd.png

- Spring MVC는 Model-View-Controller 의 구조로 View와 Controller는 프레젠테이션 계층 영역이며, Model은 비즈니스와 데이터 접근 계층의 영역으로 구분할 수 있다.
- 다만 스프링 MVC 모델로 레이어드 아키텍처를 구현하기 위해서는 역할을 세분화한다.
- 비즈니스 계층에 서비스를 배치해 엔티티와 같은 도메인 객체의 비즈니스 로직을 조합하도록 하고 데이터 접근 계층에는 DAO(Spring Data JPA에서는 Repository)를 배치해 도메인을 관리한다.
- **스프링의 레이어드 아키텍처**는 다음과 같이 설명할 수 있다.

### **프레젠테이션 계층**

- 상황에 따라 유저 인터페이스(UI; User Interface) 계층이라고도 한다.
- 클라이언트와의 접점이 된다.
- 클라이언트로부터 데이터와 함께 요청을 받고 처리 결과를 응답으로 전달하는 역할이다.

### **비즈니스 계층**

- 상황에 따라 서비스(Service) 계층이라고도 한다.
- 핵심 비즈니스 로직을 구현하는 영역이다.
- 트랜잭션 처리나 유효성 검사 등의 작업도 수행한다.

### **데이터접근 계층**

- 상황에 따라 영속(Persistence) 계층이라고도 한다.
- 데이터베이스에 접근해야 하는 작업을 수행한다.
- 위 그림에서는 DAO라는 컴포넌트를 표현했지만 Spring Data JPA에서는 DAO 역할을 리포지토리가 수행하기 때문에 리포지토리로 대체할 수 있다.

## 2.4 디자인 패턴

- 디자인 패턴(Design Pattern)은 소프트웨어를 설계할 때 자주 발생하는 문제들을 해결하기 위해 고안된 해결책이다.
- 디자인 패턴에서 ‘패턴’이라는 단어는 애플리케이션 개발에서 발생하는 문제는 유사한 경우가 많고 해결책도 동일하게 적용할 수 있다는 의미를 내포한다.
- 그러나 디자인 패턴이 모든 문제의 정답은 아니며, 상황에 맞는 최적 패턴을 결정해서 사용하는 것이 바람직하다.

### 2.4.1 디자인 패턴의 종류

- 디자인 패턴을 구체화해서 정리한 대표적인 분류 방식으로 ‘GoF 디자의 패턴’이라는 것이 있다.
- 여기서 GoF는 ‘Gang of Four’의 줄임말로, 디자인 패턴을 구체화하고 체계화해서 분류한 4명의 인물을 의미한다.

| 생성(Creational) 패턴 | 구조(Structural) 패턴 | 행위(Behavioral) 패턴 |
| --- | --- | --- |
| 추상 팩토리(Adstract Factory)빌더(Builder)팩토리 메서드(Factory Method)프로토타입(Prototype)싱글톤(Singleton) | 어댑터(Adpter)브리지(Bridge)컴포지트(Composite)데코레이터(Decorator)퍼사드(Facade)플라이웨이트(Flyweight)프락시(Proxy) | 책임 연쇄(Chain of Responsibility)커맨드(Command)인터프리터(Interpreter)이터레이터(Iterator)미디에이터(Mediator)메멘토(Memento)옵저버(Observer)스테이트(State)스트레티지(Strategy)템플릿 메서드(Template Method)비지터(Visitor) |
- GoF 디자인 패턴은 생성 패턴, 구조 패턴, 행위 패턴의 총 세 가지로 구분된다.
    - **생성 패턴**
        - 객체 생성에 사용되는 패턴으로, 객체를 수정해도 호출부가 영향을 받지 않게 한다.
    - **구조 패턴**
        - 객체를 조합해서 더 큰 구조를 만드는 패턴이다.
    - **행위 패턴**
        - 객체 간의 알고리즘이나 책임 분배에 관한 패턴이다.
        - 객체 하나로는 수행할 수 없는 작업을 여러 객체를 이용해 작업을 분배한다. 결합도 최소화를 고려할 필요가 있다.

### 2.4.2 생성 패턴

- **추상 팩토리** : 구체적인 클래스를 지정하지 않고 상황에 맞는 객체를 생성하기 위한 인터페이스를 제공하는 패턴이다.
- **빌더** : 객체의 생성과 표현을 분리해 객체를 생성하는 패턴이다.
- **팩토리 메서드** : 객체 생성을 서브 클래스로 분리해서 위임하는 패턴이다.
- **프로토타입**: 원본 객체를 복사해 객체를 생성하는 패턴이다.
- **싱글톤** : 한 클래스마다 인스턴스를 하나만 생성해서 인스턴스가 하나임을 보장하고 어느 곳에서도 접근할 수 있게 제공하는 패턴이다.

### 2.4.3 구조 패턴

- **어댑터**: 클래스의 인터페이스를 의도하는 인터페이스로 변환하는 패턴이다.
- **브리지**: 추상화와 구현을 분리해서 각각 독립적으로 변형케 하는 패턴이다.
- **컴포지트** : 여러 객체로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루는 패턴이다.
- **데코레이터** : 객체의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 하는 패턴이다.
- **퍼사드** : 서브시스템의 인터페이스 집합들에 하나의 통합된 인터페이스를 제공하는 패턴이다.
- **플라이웨이트** : 특정 클래스의 인스턴스 한 개를 가지고 여러 개의 ‘가상 인스턴스’를 제공할 때 사용하는 패턴이다.
- **프락시** : 특정 객체를 직접 참조하지 않고 해당 객체를 대행(프락시)하는 객체를 통해 접근하는 패턴이다.

### 2.4.4 행위 패턴

- **책임 연쇄** : 요청 처리 객체를 집합으로 만들어 결합을 느슨하게 만드는 패턴이다.
- **커맨드** : 실행될 기능을 캡슐화해서 주어진 여러 기능을 실행하도록 클래스를 설계하는 패턴이다.
- **인터프리터** : 주어진 언어의 문법을 위한 표현 수단으로 정의하고 해당 언어로 구성된 문장을 해석하는 패턴이다.
- **이터레이터** : 내부 구조를 노출하지 않으면서 해당 객체의 집합 원소에 순차적으로 접근하는 방법을 제공하는 패턴이다.
- **미디에이터** : 한 집합에 속한 객체들의 상호작용을 캡슐화하는 객체를 정의한 패턴이다.
- **메멘토** : 객체의 상태 정보를 저장하고 필요에 따라 상태를 복원하는 패턴이다.
- **옵저버** : 객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버 목록을 객체에 등록해 상태가 변할 때마다 메서드 등을 통해 객체가 직접 옵저버에게 통지하게 하는 디자인 패턴이다.
- **스테이트** : 상태에 따라 객체가 행동을 변경하게 하는 패턴이다.
- **스트래티지** : 행동을 클래스로 캡슐화해서 동적으로 행동을 바꿀 수 있게 하는 패턴이다.
- **템플릿 메서드** : 일정 작업을 처리하는 부분을 서브클래스로 캡슐화해서 전체 수행 구조는 바꾸지 않으면서 특정 단계만 변경해서 수행하는 패턴이다.
- **비지터** : 실제 로직을 가지고 있는 객체(visitor)가 로직을 적용할 객체(element)를 방문하여 실행하는 패턴이다.

## 2.5 REST API

- REST API는 대중적으로 가장 많이 사용되는 애플리케이션 인터페이스이다.
- 이 인터페이스를 통해 클라이언트는 서버에 접근하고 자원을 조작할 수 있다.

### 2.5.1 REST 란?

- REST란 ‘Representational State Transfer’의 약자로, 월드 와이드 웹(WWW)과 같은 분상 하이퍼미디어 시스템 아키텍처의 한 형식이다.
- 주고받는 자원(Resource)에 이름을 규정하고 URI에 명시해서 HTTP 메서드(GET, POST, PUT, DELETE)를 통해 해당 자원의 상태를 주고받는 것을 의미한다.

### 2.5.2 REST API란?

- 먼저 API는 ‘Application Programming Interface’의 약자로, 애플리케이션에서 제공하는 인터페이스를 의미한다.
- API를 통해 서버 또는 프로그램 사이를 연결할 수 있다.
- 즉 REST API 는 REST 아키텍처를 따르는 시스템/애플리케이션 인터페이스라고 볼 수 있다.
- REST 아키텍처를 구현하는 웹 서비스를 ‘RESTful하다’라고 표현한다.

### 2.5.3 REST의 특징

- **유니폼 인터페이스**
    - 유니폼 인터페이스란 ‘일관된 인터페이스’를 의미한다.
    - 즉, REST 서버는 HTTP 표준 전송 규약을 따르기 때문에 어떤 프로그래밍 언어로 만들어졌느냐와 상관없이 플랫폼 및 기술에 종속되지 않고 타 언어, 플랫폼, 기술 등과 호환해 사용할 수 있다는 것을 의미한다.
- **무상태성**
    - REST는 ‘무상태성(stateless)’이라는 특징을 가진다.
    - 무상태성이란 서버에 상태 정보를 따로 보관하거나 관리하지 않는다는 의미다.
    - 서버는 클라이언트가 보낸 요청에 대해 세션이나 쿠키 정보를 별도로 보관하지 않는다.
    - 그렇게 때문에 한 클라이언트가 여러 요청을 보내든 여러 클라이언트가 각각 하나의 요청을 보내든 개별적으로 처리한다.
    - 이렇게 구성된 서비스는 서버가 불필요한 정보를 관리하지 않으므로 비즈니스 로직의 자유도가 높고 설계가 단순하다.
- **캐시 가능성**
    - REST는 HTTP 표준을 그래도 사용하므로 HTTP의 캐싱 기능을 적용할 수 있다.
    - 이 기능을 이용하기 위해서는 응답과 요청이 모두 캐싱 가능한지(Cacheable) 명시가 필요하며 ,캐싱이 가능한 경우 클라이언트에서 캐시에 저장해두고 같은 요청에 대해서는 해당 데이터를 가져다 사용한다.
    - 이 기능을 사용하면 서버의 트랜잭션 부하가 줄어 효유율적이며 사용자 입장에서는 성능이 개선된다.
- **레이어 시스템**
    - REST 서버는 네트워크 상의 여러 계층으로 구성될 수 있다.
    - (Layered System).
    - 그러나 서버의 복잡도와 관계 없이 클라이언트는 서버와 연결된 포인트만 알면 된다.
- **클라이언트-서버 아키텍처**
    - REST 서버는 API를 제공하고 클라이언트는 사용자 정보를 관리하는 구조로 분리해 설계한다.
    - 이 구성은 서로에 대한 의존성을 낮추는 기능을 한다.

### **2.5.4 REST의 URI 설계 규칙**

- REST API를 설계하는 데는 다음과 같은 몇 가지 규칙이 있다.
- **URL 규칙**
    - **URI의 마지막에서는 ‘/’를 포함하지 않는다.**
        - 옳은 예) http://localhost.com/product
        - 잘못된 예) http://localhost.com/product/
    - **언더바(_)는 사용하지 않는다. 대신 하이픈(-)을 이용한다.**
        - 하이픈은 리소스의 이름이 길어지면 사용한다.
        - 옳은 예) http://localhost.com/provider-company-name
        - 잘못된 예) http://localhost.com/provider_compaty_name
    - **URL에는 행위(동사)가 아닌 결과(명사)를 포함한다.**
        - 옳은 예) http://localhost.com/product/123
        - 잘못된 예) http://localhost.com/delete-product/123
        - 행위는 HTTP 메서드로 표현할 수 있어야 한다.
    - **URI는 소문자로 작성해야 한다.**
        - URI 리소스 경로에는 대문자 사용할 피하는 것이 좋다.
        - 일부 웹 서버의 운영체제는 리소스 경로 부분이 대소문자를 다른 문자로 인식하기 때문이다. 이러한 이유로 RFC3986은 URI 문법 형식을 정의하고 있는데, 호스트의 구성요소를 제외하고 URI의 대소문자를 구분해서 정의하고 있다.
    - **파일의 확장자는 URI에 포함하지 않는다.**
        - HTTP에서 제공하는 Accept 헤더를 사용하는 것이 좋다.